<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
	<script type="text/javascript" src="http://latex.codecogs.com/latexit.js"></script>
	<script type="text/javascript">
		LatexIT.add('p',true);
		LatexIT.add('li',true);
		LatexIT.add('td',true);
	</script>

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Feedback Control for Hackers</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Feedback Control for Hackers</h1>
        <h2>Introduction to feedback control in computer science</h2>
        <a href="https://github.com/rvanheest/Literature-Study-Feedback-Control" class="button"><small>View project on</small> GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          
<h1>
<a id="controllers" class="anchor" href="#controllers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Controllers</h1>

<p>Previously we have seen how a feedback system (see the image below) is constructed by looping the controlled system's output <code>y</code> back into a comparison with a reference value <code>r</code>, and providing the resulting error <code>e</code> to a controller <code>K</code>, which generates the next input <code>u</code> for the controlled system <code>H</code>. In this section we will discuss the role of the controller in a feedback system. Its most obvious role is to do the 'smart' numerical work, but we also need to consider the different types of controllers, which may improve the stability, performance and accuracy of the system as a whole.</p>

<figure><img src="images/Closed-loop%20System.png" alt="Feedback system"><figcaption><div class="captiontext">Architecture of a closed-loop</div><div class="source">source: Feedback Control for Computer Systems, p.39<br/>Courtesy of O'Reilly Media</div></figcaption></figure>

<p>When designing a feedback system for controlling the size of a cache we need to consider what the input and output of the cache itself are within the feedback loop. Our reference value is a desired hit rate, which is depicted as a value between 0 and 1, as is the cache's output, to which it is compared. From this comparison, we send the error (<code>desired value - output</code>) to the controller, which is a value in the range -1 to 1. The controller then needs to calculate a new size for the cache and therefore needs to convert a ratio into a size.</p>

<p>The same holds for designing a feedback system for the example of a pipe feeding into a water tank. Here the water tank's output might be a ratio (to what percentage it is filled) or a volume (how many cubic meters of water are in), which the controller needs to convert into an action on the water supply. This action depends on the type of water supply: can it be only <em>opened</em> and <em>closed</em> or are there more states in between?</p>

<p>In general we can thus say that the controller serves the purpose of translating the controlled system's output signal into its next input signal. But as we just saw, the controller might be different, depending on the situation.</p>

<h2>
<a id="onoff-control" class="anchor" href="#onoff-control" aria-hidden="true"><span class="octicon octicon-link"></span></a>On/Off control</h2>

<p>The simplest controller is the on/off switch. Whenever the error is positive, the controlled system is turned on and visa versa. This is a very simple approach, but in practice not very effective since the system will not settle to a steady state. It will rather oscillate rapidly between its two states.</p>

<p>To show this behavior, let's implement a cruise control feedback system that uses an on/off controller. To keep the behavior of the cruise control simple, we expect any changes to be applied immediately, without any form of lag or delay. We define a class <code>SpeedSystem</code> which has a function <code>interact(setting: Boolean): Int</code> which respectively increases and decreases the <code>speed</code> variable depending on the <code>setting: Boolean</code> being <code>true</code> or <code>false</code>. We also define speed limits that vary over time in the <code>setPoint</code> function.</p>

<div class="highlight highlight-scala"><pre><span class="pl-k">class</span> <span class="pl-en">SpeedSystem</span>(<span class="pl-k">var</span> <span class="pl-en">speed</span><span class="pl-k">:</span> <span class="pl-st">Int</span> <span class="pl-k">=</span> <span class="pl-c1">10</span>) {
    <span class="pl-k">def</span> <span class="pl-en">interact</span>(<span class="pl-v">setting</span>: <span class="pl-st">Boolean</span>) <span class="pl-k">=</span> {
        speed <span class="pl-k">+</span><span class="pl-k">=</span> (<span class="pl-k">if</span> (setting) <span class="pl-c1">1</span> <span class="pl-k">else</span> <span class="pl-k">-</span><span class="pl-c1">1</span>)
        speed
    }
}</pre></div>

<div class="highlight highlight-scala"><pre><span class="pl-k">def</span> <span class="pl-en">simulation</span>()<span class="pl-k">:</span> <span class="pl-en">Observable</span>[<span class="pl-st">Int</span>] <span class="pl-k">=</span> {
    <span class="pl-k">def</span> <span class="pl-en">setPoint</span>(<span class="pl-v">time</span>: <span class="pl-st">Int</span>)<span class="pl-k">:</span> <span class="pl-st">Int</span> <span class="pl-k">=</span> {
        <span class="pl-k">if</span> (time <span class="pl-k">&lt;</span> <span class="pl-c1">10</span>) <span class="pl-c1">15</span>
        <span class="pl-k">else</span> <span class="pl-k">if</span> (time <span class="pl-k">&lt;</span> <span class="pl-c1">20</span>) <span class="pl-c1">10</span>
        <span class="pl-k">else</span> <span class="pl-c1">20</span>
    }
    <span class="pl-k">val</span> <span class="pl-en">ss</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">SpeedSystem</span>

    <span class="pl-en">Observable</span>(subscriber <span class="pl-k">=&gt;</span> {
        <span class="pl-k">val</span> <span class="pl-en">speed</span> <span class="pl-k">=</span> <span class="pl-en">BehaviorSubject</span>(ss.speed)
        speed.subscribe(subscriber)

        <span class="pl-en">Observable</span>.from(<span class="pl-c1">0</span> until <span class="pl-c1">40</span>)
            .map(setPoint)
            .zipWith(speed)(_ <span class="pl-k">-</span> _)
            .map { x <span class="pl-k">=&gt;</span> <span class="pl-k">if</span> (x <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) <span class="pl-c1">true</span> <span class="pl-k">else</span> <span class="pl-c1">false</span> }
            .map(ss.interact)
            .subscribe(speed)
    })
}</pre></div>

<p>This results in the diagram below. Here we can clearly see the oscillating behavior of the system, rather than stabilizing it on the desired value.</p>

<figure><img src="images/Cruise%20control%20-%20OnOff.png" alt="On/Off controller on cruise control system"><figcaption><div class="captiontext">Simulation of a cruise control system using an on/off controller</div><div class="source">source: <a href="https://github.com/rvanheest">Richard van Heest</a></div></figcaption></figure>

<p>To improve this controller a bit, we can introduce a dead zone or hysteresis. The former only sends an `on` signal to the system when a certain threshold is exceeded. The latter (also known as <a href="http://en.wikipedia.org/wiki/Schmitt_trigger">Schmitt trigger</a>) maintains the same corrective action when the tracking error flips from positive to negative, until some threshold is exceeded. The latter is often used in conventional heating systems.</p>

<h2>
<a id="proportional-control" class="anchor" href="#proportional-control" aria-hidden="true"><span class="octicon octicon-link"></span></a>Proportional control</h2>

<p>To improve the control we have over the system, we need to come up with something better than an on/off controller. An obvious step is to take the magnitude of the error into account when deciding on the magnitude of the corrective action. This implies that a small error leads to a small correction, whereas a large error leads to a greater corrective action. To achieve this, we let the control action be proportional to the tracking error:</p>

<p lang="latex">u_p(t) = k_p \cdot e(t)\ \ \ k_p > 0 \text{ constant}</p>

<p>Here $k_p$ is the controller gain, which is a positive constant.</p>

<p>Although this controller might be very useful in some cases, it shows one of its weaknesses when applied to the cruise control example. To do so, we first need to redefine the <code>SpeedSystem</code> class, since we now provide a <code>power: Double</code> rather than a <code>setting: Boolean</code>. If the <code>power</code> is zero or lower, the speed drops by 10%; else we increase the speed by the given power.</p>

<div class="highlight highlight-scala"><pre><span class="pl-k">class</span> <span class="pl-en">SpeedSystem</span>(<span class="pl-k">var</span> <span class="pl-en">speed</span><span class="pl-k">:</span> <span class="pl-st">Double</span> <span class="pl-k">=</span> <span class="pl-c1">10</span>) {
    <span class="pl-k">def</span> <span class="pl-en">interact</span>(<span class="pl-v">power</span>: <span class="pl-st">Double</span>) <span class="pl-k">=</span> {
        <span class="pl-k">if</span> (power <span class="pl-k">&lt;=</span> <span class="pl-c1">0</span>) {
            speed <span class="pl-k">=</span> (<span class="pl-c1">0.90</span> <span class="pl-k">*</span> speed) roundAt <span class="pl-c1">1</span>
        }
        <span class="pl-k">else</span> {
            speed <span class="pl-k">=</span> (speed <span class="pl-k">+</span> power) roundAt <span class="pl-c1">1</span>
        }
        speed
    }
}</pre></div>

<p>Now we can use the standard pattern for the simulation:</p>

<div class="highlight highlight-scala"><pre><span class="pl-k">def</span> <span class="pl-en">simulation</span>()<span class="pl-k">:</span> <span class="pl-en">Observable</span>[<span class="pl-st">Double</span>] <span class="pl-k">=</span> {
    <span class="pl-k">def</span> <span class="pl-en">setPoint</span>(<span class="pl-v">time</span>: <span class="pl-st">Int</span>)<span class="pl-k">:</span> <span class="pl-st">Int</span> <span class="pl-k">=</span> {
        <span class="pl-k">if</span> (time <span class="pl-k">&lt;</span> <span class="pl-c1">20</span>) <span class="pl-c1">15</span>
        <span class="pl-k">else</span> <span class="pl-k">if</span> (time <span class="pl-k">&lt;</span> <span class="pl-c1">40</span>) <span class="pl-c1">5</span>
        <span class="pl-k">else</span> <span class="pl-c1">20</span>
    }
    <span class="pl-k">val</span> <span class="pl-en">ss</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">SpeedSystem</span>

    <span class="pl-en">Observable</span>(subscriber <span class="pl-k">=&gt;</span> {
        <span class="pl-k">val</span> <span class="pl-en">speed</span> <span class="pl-k">=</span> <span class="pl-en">BehaviorSubject</span>(ss.speed)
        speed.subscribe(subscriber)

        <span class="pl-en">Observable</span>.from(<span class="pl-c1">0</span> until <span class="pl-c1">60</span>)
            .map(setPoint)
            .zipWith(speed)(_ <span class="pl-k">-</span> _)
            .map { k <span class="pl-k">*</span> _ }
            .map(ss.interact)
            .subscribe(speed)
    })
}</pre></div>

<p>In the diagram below we see the results with two values for $k_p$. These simulations show the typical behavior of a proportional controller. The simulation with <code>k = 0.2</code> simply never reaches the setpoint but rather stabilizes on a different value. In this case the actual stabilization value is just a little bit off, but a similar case was already shown in the <a href="./FeedbackSystems.html#experiment-2---noncumulative-controller">non-cumulative cache example</a>.</p>

<p>The other simulation (<code>k = 0.5</code>) does reach the actual setpoint, from which it follows that the next tracking error will be zero. This causes the controller to output zero, which is supplied to the <code>SpeedSystem</code>. As discussed before, this causes the speed to drop with 10%, from which the system can start rising the speed again.</p>

<figure><img src="images/Cruise%20control%20-%20proportional.png" alt="Proportional controller on cruise control system"><figcaption><div class="captiontext">Simulation of a cruise control system using a proportional controller</div><div class="source">source: <a href="https://github.com/rvanheest">Richard van Heest</a></div></figcaption></figure>

<p>What happens here in general is that the proportional controller can only produce a nonzero output if it gets a nonzero input. This directly follows from the equation above. As the tracking error diminishes, the controller output will become smaller and eventually will be zero. However, some systems (like the cruise control system or a heated pot on a stove) need a nonzero input in the steady state. If we use a proportional controller in such systems, the consequence will be that some residual error will persist; in other words the system output <code>y</code> will always be less than the desired setpoint <code>r</code>. This phenomenon is known as <em>proportional droop</em>.</p>

<h2>
<a id="integral-control" class="anchor" href="#integral-control" aria-hidden="true"><span class="octicon octicon-link"></span></a>Integral control</h2>

<p>To solve problems caused by proportional droop, we introduce a new type of controller. This controller does not look at the <em>current</em> tracking error, but uses the <em>sum of all previous tracking errors</em> to produce its newest control action. As we know from mathematics, in a continuous stream a sum becomes an integral (hence its name), resulting in the following equation.</p>

<p lang="latex">\begin{align*}
  u_i(t) &= k_i \int_{0}^{t}e(\tau) \mathrm{d} \tau\\
         &= k_i \sum_{0}^{t}e(\tau)
\end{align*}
\ \ \ k_i > 0 \text{ constant}</p>

<p>In our examples this controller is implemented as a <code>scan</code> operation, followed by a <code>map</code> and can be found in previous experiments like the <a href="./FeedbackSystems.html#experiment-1---cumulative-controller">cumulative cache experiment</a>:</p>

<div class="highlight highlight-scala"><pre>trackingError.scan((<span class="pl-v">sum</span>: <span class="pl-st">Double</span>, <span class="pl-v">e</span>: <span class="pl-st">Double</span>) <span class="pl-k">=&gt;</span> sum <span class="pl-k">+</span> e).map { k <span class="pl-k">*</span> _ }</pre></div>

<p>Most often, this controller is used in combination with the proportional controller in order to fix the earlier discovered problems with the nonzero input in the steady state phase. The integral term in this so-called <em>PI controller</em> takes care of this by providing a constant offset. When the proportional term is zero (due to the tracking error being zero), the integral term will not turn zero, since it takes the historical errors into account as well.</p>

<p>We can show the effect of combining the proportional  and integral controllers by modifying the cruise control simulation. We add a class that holds the proportional and integral terms and replace <code>.map { k * _ }</code> from the previous implementation with <code>.scan(new PI)(_ work _).drop(1).map(_.controlAction)</code>. Notice that we here drop the first emitted item: this is the initial item <code>new PI</code> which we do not want in the control loop but rather be there as a seed for what comes in the first control iteration.</p>

<div class="highlight highlight-scala"><pre><span class="pl-k">class</span> <span class="pl-en">PI</span>(<span class="pl-k">val</span> <span class="pl-en">prop</span><span class="pl-k">:</span> <span class="pl-st">Double</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>, <span class="pl-k">val</span> <span class="pl-en">integral</span><span class="pl-k">:</span> <span class="pl-st">Double</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>) {
    <span class="pl-k">def</span> <span class="pl-en">work</span>(<span class="pl-v">error</span>: <span class="pl-st">Double</span>)<span class="pl-k">:</span> <span class="pl-en">PI</span> <span class="pl-k">=</span> {
        <span class="pl-k">new</span> <span class="pl-en">PI</span>(error, integral <span class="pl-k">+</span> error)
    }

    <span class="pl-k">def</span> <span class="pl-en">controlAction</span>(<span class="pl-v">kp</span>: <span class="pl-st">Double</span>, <span class="pl-v">ki</span>: <span class="pl-st">Double</span>) <span class="pl-k">=</span> {
        prop <span class="pl-k">*</span> kp <span class="pl-k">+</span> integral <span class="pl-k">*</span> ki
    }
}</pre></div>

<div class="highlight highlight-scala"><pre><span class="pl-k">def</span> <span class="pl-en">simulation</span>()<span class="pl-k">:</span> <span class="pl-en">Observable</span>[<span class="pl-st">Double</span>] <span class="pl-k">=</span> {
    <span class="pl-k">def</span> <span class="pl-en">setPoint</span>(<span class="pl-v">time</span>: <span class="pl-st">Int</span>)<span class="pl-k">:</span> <span class="pl-st">Int</span> <span class="pl-k">=</span> {
        <span class="pl-k">if</span> (time <span class="pl-k">&lt;</span> <span class="pl-c1">20</span>) <span class="pl-c1">15</span>
        <span class="pl-k">else</span> <span class="pl-k">if</span> (time <span class="pl-k">&lt;</span> <span class="pl-c1">40</span>) <span class="pl-c1">5</span>
        <span class="pl-k">else</span> <span class="pl-c1">20</span>
    }
    <span class="pl-k">val</span> <span class="pl-en">ss</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">SpeedSystem</span>

    <span class="pl-en">Observable</span>(subscriber <span class="pl-k">=&gt;</span> {
        <span class="pl-k">val</span> <span class="pl-en">speed</span> <span class="pl-k">=</span> <span class="pl-en">BehaviorSubject</span>(ss.speed)
        speed.subscribe(subscriber)

        <span class="pl-en">Observable</span>.from(<span class="pl-c1">0</span> until <span class="pl-c1">60</span>)
            .map(setPoint)
            .zipWith(speed)(_ <span class="pl-k">-</span> _)
            .scan(<span class="pl-k">new</span> <span class="pl-en">PI)</span>(_ work _)
            .drop(<span class="pl-c1">1</span>)
            .map(_.controlAction(kp, ki))
            .map(ss.interact)
            .subscribe(speed)
    })
}</pre></div>

<p>By using this code sample we find a correct implementation for the cruise control system. Notice that we still use <code>kp = 0.5</code> and that we only need a very slight integral correction with <code>ki = 0.001</code> to achieve this.</p>

<figure><img src="images/Cruise%20control%20-%20PI.png" alt="PI controller on cruise control system"><figcaption><div class="captiontext">Simulation of a cruise control system using a PI controller</div><div class="source">source: <a href="https://github.com/rvanheest">Richard van Heest</a></div></figcaption></figure>

<h2>
<a id="derivative-control" class="anchor" href="#derivative-control" aria-hidden="true"><span class="octicon octicon-link"></span></a>Derivative control</h2>

<p>Besides the proportional controller and integral controller, which respectively control based on the present and the past, we can also try to control a feedback system based on a prediction of the future. This is done by the derivative controller. From mathematics we know that the derivative is the rate of change of some quantity. Therefore we can conclude that if the derivative of the tracking error is positive, the tracking error is currently growing (and vice versa). From this conclusion we can then take action and react to changes as fast as possible (before the tracking error has a chance to become large).</p>

<p>Mathematically we can express the derivative controller by the following equation:</p>

<p lang="latex">u_d(t) = k_d \frac{\mathrm{d} e(t)}{\mathrm{d} t}\ \ \ k_i > 0 \text{ constant}</p>

<p>Even though '<em>anticipating the future</em>' sounds promising, there are a number of problems with the derivative controller. First of all a sudden setpoint change will lead to a large momentary spike, which will be the input of the controlled system. This effect is known as <em>derivative kick</em>.<br>
Besides that the input signal of the controller can have a high-frequency noise. Taking the derivative of such a signal only makes things worse by enhancing the effect of the noise.</p>

<h2>
<a id="pid-control" class="anchor" href="#pid-control" aria-hidden="true"><span class="octicon octicon-link"></span></a>PID control</h2>

<p>The most common use of the derivative controller is in combination with the proportional and integral controllers, forming a three-term <em>PID controller</em>. Here we use all three controllers and sum the outcomes.</p>

<figure><img src="images/PIDController.png" alt="PID controller"><figcaption><div class="captiontext">Architecture of a PID controller</div><div class="source">source: Feedback Control for Computer Systems, p.48<br/>Courtesy of O'Reilly Media</div></figcaption></figure>

<p>We implement this in the same way as we did for the PI controller:</p>

<div class="highlight highlight-scala"><pre><span class="pl-k">class</span> <span class="pl-en">PID</span>(<span class="pl-k">val</span> <span class="pl-en">prop</span><span class="pl-k">:</span> <span class="pl-st">Double</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>, <span class="pl-k">val</span> <span class="pl-en">integral</span><span class="pl-k">:</span> <span class="pl-st">Double</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>, <span class="pl-k">val</span> <span class="pl-en">deriv</span><span class="pl-k">:</span> <span class="pl-st">Double</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>, <span class="pl-v">prevErr</span>: <span class="pl-st">Double</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>) {
    <span class="pl-k">def</span> <span class="pl-en">work</span>(<span class="pl-v">error</span>: <span class="pl-st">Double</span>, <span class="pl-en">DT</span><span class="pl-k">:</span> <span class="pl-st">Double</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>)<span class="pl-k">:</span> <span class="pl-en">PID</span> <span class="pl-k">=</span> {
        <span class="pl-k">new</span> <span class="pl-en">PID</span>(error, integral <span class="pl-k">+</span> error, (error <span class="pl-k">-</span> prevErr) <span class="pl-k">/</span> <span class="pl-en">DT</span>, error)
    }

    <span class="pl-k">def</span> <span class="pl-en">controlAction</span>(<span class="pl-v">kp</span>: <span class="pl-st">Double</span>, <span class="pl-v">ki</span>: <span class="pl-st">Double</span>, <span class="pl-v">kd</span>: <span class="pl-st">Double</span>) <span class="pl-k">=</span> {
        prop <span class="pl-k">*</span> kp <span class="pl-k">+</span> integral <span class="pl-k">*</span> ki <span class="pl-k">+</span> deriv <span class="pl-k">*</span> kd
    }
}</pre></div>

<p>Notice that the function <code>work</code> takes a parameter <code>DT</code> with default value <code>DT = 1</code>. This value is used in calculating the derivative to account for multiple iterations within one time unit. If time is measured in seconds and there are 100 control actions, then <code>DT = 0.01</code>. Since our simulations currently do not depend on the time unit, we can assume that we do 1 control action per time unit, from which it follows that <code>DT = 1</code>.</p>

<p>Also notice that with introducing this controller, the PI controller is needed anymore, since it is equivalent to a PID controller with <code>kd = 0.0</code>.</p>

<h2>
<a id="summary" class="anchor" href="#summary" aria-hidden="true"><span class="octicon octicon-link"></span></a>Summary</h2>

<p>In this section a number of controllers have been discussed. The most primitive one is the <strong>on/off controller</strong>. This can only signal the controlled system to turn on or off. Its results are quite poor and often cause oscillating behavior.</p>

<p>An improvement is introduced in the <strong>proportional controller</strong>, which takes the tracking error and multiplies it with some constant $k_p$. This controller performs well as long as the tracking error is not close to zero. Some types of controlled systems still need a nonzero input when the tracking error gets zero. This is what a proportional controller cannot offer.</p>

<p>To solve this issue, an <strong>integral controller</strong> can be added. This keeps track of the sum of all previous tracking errors and multiplies that with its constant $k_i$. Together with the proportional controller, this controller makes up the <strong>PI controller</strong>, which combines the power of both.</p>

<p>Besides reacting to the present tracking error and taking the past into account, we can also try to predict the future. We do this with the <strong>derivative controller</strong>, which takes the change of the tracking error and multiplies that with the constant $k_d$. Together with the PI controller, the <strong>PID controller</strong> is formed.</p>

        </section>

        <aside id="sidebar">
          <a href="https://github.com/rvanheest/Literature-Study-Feedback-Control/zipball/master" class="button">
            <small>Download the code as</small>
            .zip file
          </a>
          <a href="https://github.com/rvanheest/Literature-Study-Feedback-Control/tarball/master" class="button">
            <small>Download the code as</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><em>Feedback Control for Hackers</em> is<br/>written by <a href="https://github.com/rvanheest">Richard van Heest</a>.</p>
		  
		  <h2>Table of Contents</h2>
		  <ol>
			<li><a href="./index.html">Introduction</a></li>
			<li><a href="./FeedbackSystems.html">Feedback systems</a></li>
			<li><a href="./SystemDynamics.html">System dynamics</a></li>
			<li id="selected"><a href="./Controllers.html">Controllers</a>
				<ul>
					<li><a href="#onoff-control">On/Off control</a></li>
					<li><a href="#proportional-control">Proportional control</a></li>
					<li><a href="#integral-control">Integral control</a></li>
					<li><a href="#derivative-control">Derivative control</a></li>
					<li><a href="#pid-control">PID control</a></li>
					<li><a href="#summary">Summary</a></li>
				</ul>
			</li>
			<li><a href="./Simulation.html">Simulation</a></li>
			<li><a href="./CacheHitRate.html">Case study: Cache hit rate</a></li>
			<li><a href="./ServerScaling.html">Case study: Server scaling</a></li>
			<li><a href="./Conclusion.html">Conclusion</a></li>
		  </ol>
        </aside>
      </div>
    </div>

	<script type="text/javascript">
	  var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
	  document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
	</script>
	<script type="text/javascript">
	  try {
	    var pageTracker = _gat._getTracker("UA-60861631-1");
	  pageTracker._trackPageview();
	  } catch(err) {}
	</script>
  </body>
</html>
